/*
NetBox REST API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 4.5.1-Docker-3.4.2 (4.5)
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package netbox

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"reflect"
	"strings"
)

type UsersAPI interface {

	/*
		UsersGroupsBulkDestroy Method for UsersGroupsBulkDestroy

		Delete a list of group objects.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiUsersGroupsBulkDestroyRequest
	*/
	UsersGroupsBulkDestroy(ctx context.Context) ApiUsersGroupsBulkDestroyRequest

	// UsersGroupsBulkDestroyExecute executes the request
	UsersGroupsBulkDestroyExecute(r ApiUsersGroupsBulkDestroyRequest) (*http.Response, error)

	/*
		UsersGroupsBulkPartialUpdate Method for UsersGroupsBulkPartialUpdate

		Patch a list of group objects.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiUsersGroupsBulkPartialUpdateRequest
	*/
	UsersGroupsBulkPartialUpdate(ctx context.Context) ApiUsersGroupsBulkPartialUpdateRequest

	// UsersGroupsBulkPartialUpdateExecute executes the request
	//  @return []Group
	UsersGroupsBulkPartialUpdateExecute(r ApiUsersGroupsBulkPartialUpdateRequest) ([]Group, *http.Response, error)

	/*
		UsersGroupsBulkUpdate Method for UsersGroupsBulkUpdate

		Put a list of group objects.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiUsersGroupsBulkUpdateRequest
	*/
	UsersGroupsBulkUpdate(ctx context.Context) ApiUsersGroupsBulkUpdateRequest

	// UsersGroupsBulkUpdateExecute executes the request
	//  @return []Group
	UsersGroupsBulkUpdateExecute(r ApiUsersGroupsBulkUpdateRequest) ([]Group, *http.Response, error)

	/*
		UsersGroupsCreate Method for UsersGroupsCreate

		Post a list of group objects.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiUsersGroupsCreateRequest
	*/
	UsersGroupsCreate(ctx context.Context) ApiUsersGroupsCreateRequest

	// UsersGroupsCreateExecute executes the request
	//  @return Group
	UsersGroupsCreateExecute(r ApiUsersGroupsCreateRequest) (*Group, *http.Response, error)

	/*
		UsersGroupsDestroy Method for UsersGroupsDestroy

		Delete a group object.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param id A unique integer value identifying this group.
		@return ApiUsersGroupsDestroyRequest
	*/
	UsersGroupsDestroy(ctx context.Context, id int32) ApiUsersGroupsDestroyRequest

	// UsersGroupsDestroyExecute executes the request
	UsersGroupsDestroyExecute(r ApiUsersGroupsDestroyRequest) (*http.Response, error)

	/*
		UsersGroupsList Method for UsersGroupsList

		Get a list of group objects.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiUsersGroupsListRequest
	*/
	UsersGroupsList(ctx context.Context) ApiUsersGroupsListRequest

	// UsersGroupsListExecute executes the request
	//  @return PaginatedGroupList
	UsersGroupsListExecute(r ApiUsersGroupsListRequest) (*PaginatedGroupList, *http.Response, error)

	/*
		UsersGroupsPartialUpdate Method for UsersGroupsPartialUpdate

		Patch a group object.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param id A unique integer value identifying this group.
		@return ApiUsersGroupsPartialUpdateRequest
	*/
	UsersGroupsPartialUpdate(ctx context.Context, id int32) ApiUsersGroupsPartialUpdateRequest

	// UsersGroupsPartialUpdateExecute executes the request
	//  @return Group
	UsersGroupsPartialUpdateExecute(r ApiUsersGroupsPartialUpdateRequest) (*Group, *http.Response, error)

	/*
		UsersGroupsRetrieve Method for UsersGroupsRetrieve

		Get a group object.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param id A unique integer value identifying this group.
		@return ApiUsersGroupsRetrieveRequest
	*/
	UsersGroupsRetrieve(ctx context.Context, id int32) ApiUsersGroupsRetrieveRequest

	// UsersGroupsRetrieveExecute executes the request
	//  @return Group
	UsersGroupsRetrieveExecute(r ApiUsersGroupsRetrieveRequest) (*Group, *http.Response, error)

	/*
		UsersGroupsUpdate Method for UsersGroupsUpdate

		Put a group object.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param id A unique integer value identifying this group.
		@return ApiUsersGroupsUpdateRequest
	*/
	UsersGroupsUpdate(ctx context.Context, id int32) ApiUsersGroupsUpdateRequest

	// UsersGroupsUpdateExecute executes the request
	//  @return Group
	UsersGroupsUpdateExecute(r ApiUsersGroupsUpdateRequest) (*Group, *http.Response, error)

	/*
		UsersPermissionsBulkDestroy Method for UsersPermissionsBulkDestroy

		Delete a list of permission objects.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiUsersPermissionsBulkDestroyRequest
	*/
	UsersPermissionsBulkDestroy(ctx context.Context) ApiUsersPermissionsBulkDestroyRequest

	// UsersPermissionsBulkDestroyExecute executes the request
	UsersPermissionsBulkDestroyExecute(r ApiUsersPermissionsBulkDestroyRequest) (*http.Response, error)

	/*
		UsersPermissionsBulkPartialUpdate Method for UsersPermissionsBulkPartialUpdate

		Patch a list of permission objects.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiUsersPermissionsBulkPartialUpdateRequest
	*/
	UsersPermissionsBulkPartialUpdate(ctx context.Context) ApiUsersPermissionsBulkPartialUpdateRequest

	// UsersPermissionsBulkPartialUpdateExecute executes the request
	//  @return []ObjectPermission
	UsersPermissionsBulkPartialUpdateExecute(r ApiUsersPermissionsBulkPartialUpdateRequest) ([]ObjectPermission, *http.Response, error)

	/*
		UsersPermissionsBulkUpdate Method for UsersPermissionsBulkUpdate

		Put a list of permission objects.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiUsersPermissionsBulkUpdateRequest
	*/
	UsersPermissionsBulkUpdate(ctx context.Context) ApiUsersPermissionsBulkUpdateRequest

	// UsersPermissionsBulkUpdateExecute executes the request
	//  @return []ObjectPermission
	UsersPermissionsBulkUpdateExecute(r ApiUsersPermissionsBulkUpdateRequest) ([]ObjectPermission, *http.Response, error)

	/*
		UsersPermissionsCreate Method for UsersPermissionsCreate

		Post a list of permission objects.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiUsersPermissionsCreateRequest
	*/
	UsersPermissionsCreate(ctx context.Context) ApiUsersPermissionsCreateRequest

	// UsersPermissionsCreateExecute executes the request
	//  @return ObjectPermission
	UsersPermissionsCreateExecute(r ApiUsersPermissionsCreateRequest) (*ObjectPermission, *http.Response, error)

	/*
		UsersPermissionsDestroy Method for UsersPermissionsDestroy

		Delete a permission object.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param id A unique integer value identifying this permission.
		@return ApiUsersPermissionsDestroyRequest
	*/
	UsersPermissionsDestroy(ctx context.Context, id int32) ApiUsersPermissionsDestroyRequest

	// UsersPermissionsDestroyExecute executes the request
	UsersPermissionsDestroyExecute(r ApiUsersPermissionsDestroyRequest) (*http.Response, error)

	/*
		UsersPermissionsList Method for UsersPermissionsList

		Get a list of permission objects.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiUsersPermissionsListRequest
	*/
	UsersPermissionsList(ctx context.Context) ApiUsersPermissionsListRequest

	// UsersPermissionsListExecute executes the request
	//  @return PaginatedObjectPermissionList
	UsersPermissionsListExecute(r ApiUsersPermissionsListRequest) (*PaginatedObjectPermissionList, *http.Response, error)

	/*
		UsersPermissionsPartialUpdate Method for UsersPermissionsPartialUpdate

		Patch a permission object.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param id A unique integer value identifying this permission.
		@return ApiUsersPermissionsPartialUpdateRequest
	*/
	UsersPermissionsPartialUpdate(ctx context.Context, id int32) ApiUsersPermissionsPartialUpdateRequest

	// UsersPermissionsPartialUpdateExecute executes the request
	//  @return ObjectPermission
	UsersPermissionsPartialUpdateExecute(r ApiUsersPermissionsPartialUpdateRequest) (*ObjectPermission, *http.Response, error)

	/*
		UsersPermissionsRetrieve Method for UsersPermissionsRetrieve

		Get a permission object.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param id A unique integer value identifying this permission.
		@return ApiUsersPermissionsRetrieveRequest
	*/
	UsersPermissionsRetrieve(ctx context.Context, id int32) ApiUsersPermissionsRetrieveRequest

	// UsersPermissionsRetrieveExecute executes the request
	//  @return ObjectPermission
	UsersPermissionsRetrieveExecute(r ApiUsersPermissionsRetrieveRequest) (*ObjectPermission, *http.Response, error)

	/*
		UsersPermissionsUpdate Method for UsersPermissionsUpdate

		Put a permission object.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param id A unique integer value identifying this permission.
		@return ApiUsersPermissionsUpdateRequest
	*/
	UsersPermissionsUpdate(ctx context.Context, id int32) ApiUsersPermissionsUpdateRequest

	// UsersPermissionsUpdateExecute executes the request
	//  @return ObjectPermission
	UsersPermissionsUpdateExecute(r ApiUsersPermissionsUpdateRequest) (*ObjectPermission, *http.Response, error)
}

// UsersAPIService UsersAPI service
type UsersAPIService service

type ApiUsersGroupsBulkDestroyRequest struct {
	ctx          context.Context
	ApiService   UsersAPI
	groupRequest *[]GroupRequest
}

func (r ApiUsersGroupsBulkDestroyRequest) GroupRequest(groupRequest []GroupRequest) ApiUsersGroupsBulkDestroyRequest {
	r.groupRequest = &groupRequest
	return r
}

func (r ApiUsersGroupsBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.UsersGroupsBulkDestroyExecute(r)
}

/*
UsersGroupsBulkDestroy Method for UsersGroupsBulkDestroy

Delete a list of group objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiUsersGroupsBulkDestroyRequest
*/
func (a *UsersAPIService) UsersGroupsBulkDestroy(ctx context.Context) ApiUsersGroupsBulkDestroyRequest {
	return ApiUsersGroupsBulkDestroyRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *UsersAPIService) UsersGroupsBulkDestroyExecute(r ApiUsersGroupsBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.UsersGroupsBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/users/groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.groupRequest == nil {
		return nil, reportError("groupRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.groupRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersGroupsBulkPartialUpdateRequest struct {
	ctx          context.Context
	ApiService   UsersAPI
	groupRequest *[]GroupRequest
}

func (r ApiUsersGroupsBulkPartialUpdateRequest) GroupRequest(groupRequest []GroupRequest) ApiUsersGroupsBulkPartialUpdateRequest {
	r.groupRequest = &groupRequest
	return r
}

func (r ApiUsersGroupsBulkPartialUpdateRequest) Execute() ([]Group, *http.Response, error) {
	return r.ApiService.UsersGroupsBulkPartialUpdateExecute(r)
}

/*
UsersGroupsBulkPartialUpdate Method for UsersGroupsBulkPartialUpdate

Patch a list of group objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiUsersGroupsBulkPartialUpdateRequest
*/
func (a *UsersAPIService) UsersGroupsBulkPartialUpdate(ctx context.Context) ApiUsersGroupsBulkPartialUpdateRequest {
	return ApiUsersGroupsBulkPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []Group
func (a *UsersAPIService) UsersGroupsBulkPartialUpdateExecute(r ApiUsersGroupsBulkPartialUpdateRequest) ([]Group, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []Group
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.UsersGroupsBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/users/groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.groupRequest == nil {
		return localVarReturnValue, nil, reportError("groupRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.groupRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersGroupsBulkUpdateRequest struct {
	ctx          context.Context
	ApiService   UsersAPI
	groupRequest *[]GroupRequest
}

func (r ApiUsersGroupsBulkUpdateRequest) GroupRequest(groupRequest []GroupRequest) ApiUsersGroupsBulkUpdateRequest {
	r.groupRequest = &groupRequest
	return r
}

func (r ApiUsersGroupsBulkUpdateRequest) Execute() ([]Group, *http.Response, error) {
	return r.ApiService.UsersGroupsBulkUpdateExecute(r)
}

/*
UsersGroupsBulkUpdate Method for UsersGroupsBulkUpdate

Put a list of group objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiUsersGroupsBulkUpdateRequest
*/
func (a *UsersAPIService) UsersGroupsBulkUpdate(ctx context.Context) ApiUsersGroupsBulkUpdateRequest {
	return ApiUsersGroupsBulkUpdateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []Group
func (a *UsersAPIService) UsersGroupsBulkUpdateExecute(r ApiUsersGroupsBulkUpdateRequest) ([]Group, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []Group
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.UsersGroupsBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/users/groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.groupRequest == nil {
		return localVarReturnValue, nil, reportError("groupRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.groupRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersGroupsCreateRequest struct {
	ctx                      context.Context
	ApiService               UsersAPI
	usersGroupsCreateRequest *UsersGroupsCreateRequest
}

func (r ApiUsersGroupsCreateRequest) UsersGroupsCreateRequest(usersGroupsCreateRequest UsersGroupsCreateRequest) ApiUsersGroupsCreateRequest {
	r.usersGroupsCreateRequest = &usersGroupsCreateRequest
	return r
}

func (r ApiUsersGroupsCreateRequest) Execute() (*Group, *http.Response, error) {
	return r.ApiService.UsersGroupsCreateExecute(r)
}

/*
UsersGroupsCreate Method for UsersGroupsCreate

Post a list of group objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiUsersGroupsCreateRequest
*/
func (a *UsersAPIService) UsersGroupsCreate(ctx context.Context) ApiUsersGroupsCreateRequest {
	return ApiUsersGroupsCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return Group
func (a *UsersAPIService) UsersGroupsCreateExecute(r ApiUsersGroupsCreateRequest) (*Group, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Group
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.UsersGroupsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/users/groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.usersGroupsCreateRequest == nil {
		return localVarReturnValue, nil, reportError("usersGroupsCreateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.usersGroupsCreateRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersGroupsDestroyRequest struct {
	ctx        context.Context
	ApiService UsersAPI
	id         int32
}

func (r ApiUsersGroupsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.UsersGroupsDestroyExecute(r)
}

/*
UsersGroupsDestroy Method for UsersGroupsDestroy

Delete a group object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this group.
	@return ApiUsersGroupsDestroyRequest
*/
func (a *UsersAPIService) UsersGroupsDestroy(ctx context.Context, id int32) ApiUsersGroupsDestroyRequest {
	return ApiUsersGroupsDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *UsersAPIService) UsersGroupsDestroyExecute(r ApiUsersGroupsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.UsersGroupsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/users/groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersGroupsListRequest struct {
	ctx                  context.Context
	ApiService           UsersAPI
	description          *[]string
	descriptionEmpty     *bool
	descriptionIc        *[]string
	descriptionIe        *[]string
	descriptionIew       *[]string
	descriptionIregex    *[]string
	descriptionIsw       *[]string
	descriptionN         *[]string
	descriptionNic       *[]string
	descriptionNie       *[]string
	descriptionNiew      *[]string
	descriptionNisw      *[]string
	descriptionRegex     *[]string
	id                   *[]int32
	idEmpty              *bool
	idGt                 *[]int32
	idGte                *[]int32
	idLt                 *[]int32
	idLte                *[]int32
	idN                  *[]int32
	limit                *int32
	name                 *[]string
	nameEmpty            *bool
	nameIc               *[]string
	nameIe               *[]string
	nameIew              *[]string
	nameIregex           *[]string
	nameIsw              *[]string
	nameN                *[]string
	nameNic              *[]string
	nameNie              *[]string
	nameNiew             *[]string
	nameNisw             *[]string
	nameRegex            *[]string
	notificationGroupId  *[]int32
	notificationGroupIdN *[]int32
	offset               *int32
	ordering             *string
	owner                *[]string
	ownerN               *[]string
	ownerId              *[]int32
	ownerIdN             *[]int32
	permissionId         *[]int32
	permissionIdN        *[]int32
	q                    *string
	userId               *[]int32
	userIdN              *[]int32
}

func (r ApiUsersGroupsListRequest) Description(description []string) ApiUsersGroupsListRequest {
	r.description = &description
	return r
}

func (r ApiUsersGroupsListRequest) DescriptionEmpty(descriptionEmpty bool) ApiUsersGroupsListRequest {
	r.descriptionEmpty = &descriptionEmpty
	return r
}

func (r ApiUsersGroupsListRequest) DescriptionIc(descriptionIc []string) ApiUsersGroupsListRequest {
	r.descriptionIc = &descriptionIc
	return r
}

func (r ApiUsersGroupsListRequest) DescriptionIe(descriptionIe []string) ApiUsersGroupsListRequest {
	r.descriptionIe = &descriptionIe
	return r
}

func (r ApiUsersGroupsListRequest) DescriptionIew(descriptionIew []string) ApiUsersGroupsListRequest {
	r.descriptionIew = &descriptionIew
	return r
}

func (r ApiUsersGroupsListRequest) DescriptionIregex(descriptionIregex []string) ApiUsersGroupsListRequest {
	r.descriptionIregex = &descriptionIregex
	return r
}

func (r ApiUsersGroupsListRequest) DescriptionIsw(descriptionIsw []string) ApiUsersGroupsListRequest {
	r.descriptionIsw = &descriptionIsw
	return r
}

func (r ApiUsersGroupsListRequest) DescriptionN(descriptionN []string) ApiUsersGroupsListRequest {
	r.descriptionN = &descriptionN
	return r
}

func (r ApiUsersGroupsListRequest) DescriptionNic(descriptionNic []string) ApiUsersGroupsListRequest {
	r.descriptionNic = &descriptionNic
	return r
}

func (r ApiUsersGroupsListRequest) DescriptionNie(descriptionNie []string) ApiUsersGroupsListRequest {
	r.descriptionNie = &descriptionNie
	return r
}

func (r ApiUsersGroupsListRequest) DescriptionNiew(descriptionNiew []string) ApiUsersGroupsListRequest {
	r.descriptionNiew = &descriptionNiew
	return r
}

func (r ApiUsersGroupsListRequest) DescriptionNisw(descriptionNisw []string) ApiUsersGroupsListRequest {
	r.descriptionNisw = &descriptionNisw
	return r
}

func (r ApiUsersGroupsListRequest) DescriptionRegex(descriptionRegex []string) ApiUsersGroupsListRequest {
	r.descriptionRegex = &descriptionRegex
	return r
}

func (r ApiUsersGroupsListRequest) Id(id []int32) ApiUsersGroupsListRequest {
	r.id = &id
	return r
}

func (r ApiUsersGroupsListRequest) IdEmpty(idEmpty bool) ApiUsersGroupsListRequest {
	r.idEmpty = &idEmpty
	return r
}

func (r ApiUsersGroupsListRequest) IdGt(idGt []int32) ApiUsersGroupsListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiUsersGroupsListRequest) IdGte(idGte []int32) ApiUsersGroupsListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiUsersGroupsListRequest) IdLt(idLt []int32) ApiUsersGroupsListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiUsersGroupsListRequest) IdLte(idLte []int32) ApiUsersGroupsListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiUsersGroupsListRequest) IdN(idN []int32) ApiUsersGroupsListRequest {
	r.idN = &idN
	return r
}

// Number of results to return per page.
func (r ApiUsersGroupsListRequest) Limit(limit int32) ApiUsersGroupsListRequest {
	r.limit = &limit
	return r
}

func (r ApiUsersGroupsListRequest) Name(name []string) ApiUsersGroupsListRequest {
	r.name = &name
	return r
}

func (r ApiUsersGroupsListRequest) NameEmpty(nameEmpty bool) ApiUsersGroupsListRequest {
	r.nameEmpty = &nameEmpty
	return r
}

func (r ApiUsersGroupsListRequest) NameIc(nameIc []string) ApiUsersGroupsListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiUsersGroupsListRequest) NameIe(nameIe []string) ApiUsersGroupsListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiUsersGroupsListRequest) NameIew(nameIew []string) ApiUsersGroupsListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiUsersGroupsListRequest) NameIregex(nameIregex []string) ApiUsersGroupsListRequest {
	r.nameIregex = &nameIregex
	return r
}

func (r ApiUsersGroupsListRequest) NameIsw(nameIsw []string) ApiUsersGroupsListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiUsersGroupsListRequest) NameN(nameN []string) ApiUsersGroupsListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiUsersGroupsListRequest) NameNic(nameNic []string) ApiUsersGroupsListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiUsersGroupsListRequest) NameNie(nameNie []string) ApiUsersGroupsListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiUsersGroupsListRequest) NameNiew(nameNiew []string) ApiUsersGroupsListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiUsersGroupsListRequest) NameNisw(nameNisw []string) ApiUsersGroupsListRequest {
	r.nameNisw = &nameNisw
	return r
}

func (r ApiUsersGroupsListRequest) NameRegex(nameRegex []string) ApiUsersGroupsListRequest {
	r.nameRegex = &nameRegex
	return r
}

// Notification group (ID)
func (r ApiUsersGroupsListRequest) NotificationGroupId(notificationGroupId []int32) ApiUsersGroupsListRequest {
	r.notificationGroupId = &notificationGroupId
	return r
}

// Notification group (ID)
func (r ApiUsersGroupsListRequest) NotificationGroupIdN(notificationGroupIdN []int32) ApiUsersGroupsListRequest {
	r.notificationGroupIdN = &notificationGroupIdN
	return r
}

// The initial index from which to return the results.
func (r ApiUsersGroupsListRequest) Offset(offset int32) ApiUsersGroupsListRequest {
	r.offset = &offset
	return r
}

// Which field to use when ordering the results.
func (r ApiUsersGroupsListRequest) Ordering(ordering string) ApiUsersGroupsListRequest {
	r.ordering = &ordering
	return r
}

// Owner (name)
func (r ApiUsersGroupsListRequest) Owner(owner []string) ApiUsersGroupsListRequest {
	r.owner = &owner
	return r
}

// Owner (name)
func (r ApiUsersGroupsListRequest) OwnerN(ownerN []string) ApiUsersGroupsListRequest {
	r.ownerN = &ownerN
	return r
}

// Owner (ID)
func (r ApiUsersGroupsListRequest) OwnerId(ownerId []int32) ApiUsersGroupsListRequest {
	r.ownerId = &ownerId
	return r
}

// Owner (ID)
func (r ApiUsersGroupsListRequest) OwnerIdN(ownerIdN []int32) ApiUsersGroupsListRequest {
	r.ownerIdN = &ownerIdN
	return r
}

// Permission (ID)
func (r ApiUsersGroupsListRequest) PermissionId(permissionId []int32) ApiUsersGroupsListRequest {
	r.permissionId = &permissionId
	return r
}

// Permission (ID)
func (r ApiUsersGroupsListRequest) PermissionIdN(permissionIdN []int32) ApiUsersGroupsListRequest {
	r.permissionIdN = &permissionIdN
	return r
}

// Search
func (r ApiUsersGroupsListRequest) Q(q string) ApiUsersGroupsListRequest {
	r.q = &q
	return r
}

// User (ID)
func (r ApiUsersGroupsListRequest) UserId(userId []int32) ApiUsersGroupsListRequest {
	r.userId = &userId
	return r
}

// User (ID)
func (r ApiUsersGroupsListRequest) UserIdN(userIdN []int32) ApiUsersGroupsListRequest {
	r.userIdN = &userIdN
	return r
}

func (r ApiUsersGroupsListRequest) Execute() (*PaginatedGroupList, *http.Response, error) {
	return r.ApiService.UsersGroupsListExecute(r)
}

/*
UsersGroupsList Method for UsersGroupsList

Get a list of group objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiUsersGroupsListRequest
*/
func (a *UsersAPIService) UsersGroupsList(ctx context.Context) ApiUsersGroupsListRequest {
	return ApiUsersGroupsListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PaginatedGroupList
func (a *UsersAPIService) UsersGroupsListExecute(r ApiUsersGroupsListRequest) (*PaginatedGroupList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedGroupList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.UsersGroupsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/users/groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.description != nil {
		t := *r.description
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description", t, "form", "multi")
		}
	}
	if r.descriptionEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description__empty", r.descriptionEmpty, "form", "")
	}
	if r.descriptionIc != nil {
		t := *r.descriptionIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", t, "form", "multi")
		}
	}
	if r.descriptionIe != nil {
		t := *r.descriptionIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", t, "form", "multi")
		}
	}
	if r.descriptionIew != nil {
		t := *r.descriptionIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", t, "form", "multi")
		}
	}
	if r.descriptionIregex != nil {
		t := *r.descriptionIregex
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__iregex", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__iregex", t, "form", "multi")
		}
	}
	if r.descriptionIsw != nil {
		t := *r.descriptionIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", t, "form", "multi")
		}
	}
	if r.descriptionN != nil {
		t := *r.descriptionN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", t, "form", "multi")
		}
	}
	if r.descriptionNic != nil {
		t := *r.descriptionNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", t, "form", "multi")
		}
	}
	if r.descriptionNie != nil {
		t := *r.descriptionNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", t, "form", "multi")
		}
	}
	if r.descriptionNiew != nil {
		t := *r.descriptionNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", t, "form", "multi")
		}
	}
	if r.descriptionNisw != nil {
		t := *r.descriptionNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", t, "form", "multi")
		}
	}
	if r.descriptionRegex != nil {
		t := *r.descriptionRegex
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__regex", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__regex", t, "form", "multi")
		}
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "form", "multi")
		}
	}
	if r.idEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id__empty", r.idEmpty, "form", "")
	}
	if r.idGt != nil {
		t := *r.idGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__gt", t, "form", "multi")
		}
	}
	if r.idGte != nil {
		t := *r.idGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__gte", t, "form", "multi")
		}
	}
	if r.idLt != nil {
		t := *r.idLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__lt", t, "form", "multi")
		}
	}
	if r.idLte != nil {
		t := *r.idLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__lte", t, "form", "multi")
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", t, "form", "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.name != nil {
		t := *r.name
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name", t, "form", "multi")
		}
	}
	if r.nameEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name__empty", r.nameEmpty, "form", "")
	}
	if r.nameIc != nil {
		t := *r.nameIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", t, "form", "multi")
		}
	}
	if r.nameIe != nil {
		t := *r.nameIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", t, "form", "multi")
		}
	}
	if r.nameIew != nil {
		t := *r.nameIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", t, "form", "multi")
		}
	}
	if r.nameIregex != nil {
		t := *r.nameIregex
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__iregex", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__iregex", t, "form", "multi")
		}
	}
	if r.nameIsw != nil {
		t := *r.nameIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", t, "form", "multi")
		}
	}
	if r.nameN != nil {
		t := *r.nameN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", t, "form", "multi")
		}
	}
	if r.nameNic != nil {
		t := *r.nameNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", t, "form", "multi")
		}
	}
	if r.nameNie != nil {
		t := *r.nameNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", t, "form", "multi")
		}
	}
	if r.nameNiew != nil {
		t := *r.nameNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", t, "form", "multi")
		}
	}
	if r.nameNisw != nil {
		t := *r.nameNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", t, "form", "multi")
		}
	}
	if r.nameRegex != nil {
		t := *r.nameRegex
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__regex", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__regex", t, "form", "multi")
		}
	}
	if r.notificationGroupId != nil {
		t := *r.notificationGroupId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "notification_group_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "notification_group_id", t, "form", "multi")
		}
	}
	if r.notificationGroupIdN != nil {
		t := *r.notificationGroupIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "notification_group_id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "notification_group_id__n", t, "form", "multi")
		}
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "form", "")
	}
	if r.owner != nil {
		t := *r.owner
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "owner", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "owner", t, "form", "multi")
		}
	}
	if r.ownerN != nil {
		t := *r.ownerN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "owner__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "owner__n", t, "form", "multi")
		}
	}
	if r.ownerId != nil {
		t := *r.ownerId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "owner_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "owner_id", t, "form", "multi")
		}
	}
	if r.ownerIdN != nil {
		t := *r.ownerIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "owner_id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "owner_id__n", t, "form", "multi")
		}
	}
	if r.permissionId != nil {
		t := *r.permissionId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "permission_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "permission_id", t, "form", "multi")
		}
	}
	if r.permissionIdN != nil {
		t := *r.permissionIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "permission_id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "permission_id__n", t, "form", "multi")
		}
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "form", "")
	}
	if r.userId != nil {
		t := *r.userId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "user_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "user_id", t, "form", "multi")
		}
	}
	if r.userIdN != nil {
		t := *r.userIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "user_id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "user_id__n", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersGroupsPartialUpdateRequest struct {
	ctx                 context.Context
	ApiService          UsersAPI
	id                  int32
	patchedGroupRequest *PatchedGroupRequest
}

func (r ApiUsersGroupsPartialUpdateRequest) PatchedGroupRequest(patchedGroupRequest PatchedGroupRequest) ApiUsersGroupsPartialUpdateRequest {
	r.patchedGroupRequest = &patchedGroupRequest
	return r
}

func (r ApiUsersGroupsPartialUpdateRequest) Execute() (*Group, *http.Response, error) {
	return r.ApiService.UsersGroupsPartialUpdateExecute(r)
}

/*
UsersGroupsPartialUpdate Method for UsersGroupsPartialUpdate

Patch a group object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this group.
	@return ApiUsersGroupsPartialUpdateRequest
*/
func (a *UsersAPIService) UsersGroupsPartialUpdate(ctx context.Context, id int32) ApiUsersGroupsPartialUpdateRequest {
	return ApiUsersGroupsPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return Group
func (a *UsersAPIService) UsersGroupsPartialUpdateExecute(r ApiUsersGroupsPartialUpdateRequest) (*Group, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Group
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.UsersGroupsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/users/groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedGroupRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersGroupsRetrieveRequest struct {
	ctx        context.Context
	ApiService UsersAPI
	id         int32
}

func (r ApiUsersGroupsRetrieveRequest) Execute() (*Group, *http.Response, error) {
	return r.ApiService.UsersGroupsRetrieveExecute(r)
}

/*
UsersGroupsRetrieve Method for UsersGroupsRetrieve

Get a group object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this group.
	@return ApiUsersGroupsRetrieveRequest
*/
func (a *UsersAPIService) UsersGroupsRetrieve(ctx context.Context, id int32) ApiUsersGroupsRetrieveRequest {
	return ApiUsersGroupsRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return Group
func (a *UsersAPIService) UsersGroupsRetrieveExecute(r ApiUsersGroupsRetrieveRequest) (*Group, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Group
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.UsersGroupsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/users/groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersGroupsUpdateRequest struct {
	ctx          context.Context
	ApiService   UsersAPI
	id           int32
	groupRequest *GroupRequest
}

func (r ApiUsersGroupsUpdateRequest) GroupRequest(groupRequest GroupRequest) ApiUsersGroupsUpdateRequest {
	r.groupRequest = &groupRequest
	return r
}

func (r ApiUsersGroupsUpdateRequest) Execute() (*Group, *http.Response, error) {
	return r.ApiService.UsersGroupsUpdateExecute(r)
}

/*
UsersGroupsUpdate Method for UsersGroupsUpdate

Put a group object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this group.
	@return ApiUsersGroupsUpdateRequest
*/
func (a *UsersAPIService) UsersGroupsUpdate(ctx context.Context, id int32) ApiUsersGroupsUpdateRequest {
	return ApiUsersGroupsUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return Group
func (a *UsersAPIService) UsersGroupsUpdateExecute(r ApiUsersGroupsUpdateRequest) (*Group, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Group
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.UsersGroupsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/users/groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.groupRequest == nil {
		return localVarReturnValue, nil, reportError("groupRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.groupRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersPermissionsBulkDestroyRequest struct {
	ctx                     context.Context
	ApiService              UsersAPI
	objectPermissionRequest *[]ObjectPermissionRequest
}

func (r ApiUsersPermissionsBulkDestroyRequest) ObjectPermissionRequest(objectPermissionRequest []ObjectPermissionRequest) ApiUsersPermissionsBulkDestroyRequest {
	r.objectPermissionRequest = &objectPermissionRequest
	return r
}

func (r ApiUsersPermissionsBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.UsersPermissionsBulkDestroyExecute(r)
}

/*
UsersPermissionsBulkDestroy Method for UsersPermissionsBulkDestroy

Delete a list of permission objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiUsersPermissionsBulkDestroyRequest
*/
func (a *UsersAPIService) UsersPermissionsBulkDestroy(ctx context.Context) ApiUsersPermissionsBulkDestroyRequest {
	return ApiUsersPermissionsBulkDestroyRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *UsersAPIService) UsersPermissionsBulkDestroyExecute(r ApiUsersPermissionsBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.UsersPermissionsBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/users/permissions/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.objectPermissionRequest == nil {
		return nil, reportError("objectPermissionRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.objectPermissionRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersPermissionsBulkPartialUpdateRequest struct {
	ctx                     context.Context
	ApiService              UsersAPI
	objectPermissionRequest *[]ObjectPermissionRequest
}

func (r ApiUsersPermissionsBulkPartialUpdateRequest) ObjectPermissionRequest(objectPermissionRequest []ObjectPermissionRequest) ApiUsersPermissionsBulkPartialUpdateRequest {
	r.objectPermissionRequest = &objectPermissionRequest
	return r
}

func (r ApiUsersPermissionsBulkPartialUpdateRequest) Execute() ([]ObjectPermission, *http.Response, error) {
	return r.ApiService.UsersPermissionsBulkPartialUpdateExecute(r)
}

/*
UsersPermissionsBulkPartialUpdate Method for UsersPermissionsBulkPartialUpdate

Patch a list of permission objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiUsersPermissionsBulkPartialUpdateRequest
*/
func (a *UsersAPIService) UsersPermissionsBulkPartialUpdate(ctx context.Context) ApiUsersPermissionsBulkPartialUpdateRequest {
	return ApiUsersPermissionsBulkPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []ObjectPermission
func (a *UsersAPIService) UsersPermissionsBulkPartialUpdateExecute(r ApiUsersPermissionsBulkPartialUpdateRequest) ([]ObjectPermission, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []ObjectPermission
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.UsersPermissionsBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/users/permissions/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.objectPermissionRequest == nil {
		return localVarReturnValue, nil, reportError("objectPermissionRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.objectPermissionRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersPermissionsBulkUpdateRequest struct {
	ctx                     context.Context
	ApiService              UsersAPI
	objectPermissionRequest *[]ObjectPermissionRequest
}

func (r ApiUsersPermissionsBulkUpdateRequest) ObjectPermissionRequest(objectPermissionRequest []ObjectPermissionRequest) ApiUsersPermissionsBulkUpdateRequest {
	r.objectPermissionRequest = &objectPermissionRequest
	return r
}

func (r ApiUsersPermissionsBulkUpdateRequest) Execute() ([]ObjectPermission, *http.Response, error) {
	return r.ApiService.UsersPermissionsBulkUpdateExecute(r)
}

/*
UsersPermissionsBulkUpdate Method for UsersPermissionsBulkUpdate

Put a list of permission objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiUsersPermissionsBulkUpdateRequest
*/
func (a *UsersAPIService) UsersPermissionsBulkUpdate(ctx context.Context) ApiUsersPermissionsBulkUpdateRequest {
	return ApiUsersPermissionsBulkUpdateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []ObjectPermission
func (a *UsersAPIService) UsersPermissionsBulkUpdateExecute(r ApiUsersPermissionsBulkUpdateRequest) ([]ObjectPermission, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []ObjectPermission
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.UsersPermissionsBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/users/permissions/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.objectPermissionRequest == nil {
		return localVarReturnValue, nil, reportError("objectPermissionRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.objectPermissionRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersPermissionsCreateRequest struct {
	ctx                           context.Context
	ApiService                    UsersAPI
	usersPermissionsCreateRequest *UsersPermissionsCreateRequest
}

func (r ApiUsersPermissionsCreateRequest) UsersPermissionsCreateRequest(usersPermissionsCreateRequest UsersPermissionsCreateRequest) ApiUsersPermissionsCreateRequest {
	r.usersPermissionsCreateRequest = &usersPermissionsCreateRequest
	return r
}

func (r ApiUsersPermissionsCreateRequest) Execute() (*ObjectPermission, *http.Response, error) {
	return r.ApiService.UsersPermissionsCreateExecute(r)
}

/*
UsersPermissionsCreate Method for UsersPermissionsCreate

Post a list of permission objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiUsersPermissionsCreateRequest
*/
func (a *UsersAPIService) UsersPermissionsCreate(ctx context.Context) ApiUsersPermissionsCreateRequest {
	return ApiUsersPermissionsCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return ObjectPermission
func (a *UsersAPIService) UsersPermissionsCreateExecute(r ApiUsersPermissionsCreateRequest) (*ObjectPermission, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ObjectPermission
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.UsersPermissionsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/users/permissions/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.usersPermissionsCreateRequest == nil {
		return localVarReturnValue, nil, reportError("usersPermissionsCreateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.usersPermissionsCreateRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersPermissionsDestroyRequest struct {
	ctx        context.Context
	ApiService UsersAPI
	id         int32
}

func (r ApiUsersPermissionsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.UsersPermissionsDestroyExecute(r)
}

/*
UsersPermissionsDestroy Method for UsersPermissionsDestroy

Delete a permission object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this permission.
	@return ApiUsersPermissionsDestroyRequest
*/
func (a *UsersAPIService) UsersPermissionsDestroy(ctx context.Context, id int32) ApiUsersPermissionsDestroyRequest {
	return ApiUsersPermissionsDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *UsersAPIService) UsersPermissionsDestroyExecute(r ApiUsersPermissionsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.UsersPermissionsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/users/permissions/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersPermissionsListRequest struct {
	ctx               context.Context
	ApiService        UsersAPI
	canAdd            *bool
	canChange         *bool
	canDelete         *bool
	canView           *bool
	description       *[]string
	descriptionEmpty  *bool
	descriptionIc     *[]string
	descriptionIe     *[]string
	descriptionIew    *[]string
	descriptionIregex *[]string
	descriptionIsw    *[]string
	descriptionN      *[]string
	descriptionNic    *[]string
	descriptionNie    *[]string
	descriptionNiew   *[]string
	descriptionNisw   *[]string
	descriptionRegex  *[]string
	enabled           *bool
	group             *[]string
	groupN            *[]string
	groupId           *[]int32
	groupIdN          *[]int32
	id                *[]int32
	idEmpty           *bool
	idGt              *[]int32
	idGte             *[]int32
	idLt              *[]int32
	idLte             *[]int32
	idN               *[]int32
	limit             *int32
	name              *[]string
	nameEmpty         *bool
	nameIc            *[]string
	nameIe            *[]string
	nameIew           *[]string
	nameIregex        *[]string
	nameIsw           *[]string
	nameN             *[]string
	nameNic           *[]string
	nameNie           *[]string
	nameNiew          *[]string
	nameNisw          *[]string
	nameRegex         *[]string
	objectType        *string
	objectTypeIc      *string
	objectTypeIe      *string
	objectTypeIew     *string
	objectTypeIregex  *string
	objectTypeIsw     *string
	objectTypeN       *string
	objectTypeNic     *string
	objectTypeNie     *string
	objectTypeNiew    *string
	objectTypeNisw    *string
	objectTypeRegex   *string
	objectTypeId      *[]int32
	objectTypeIdN     *[]int32
	objectTypes       *[]int32
	objectTypesN      *[]int32
	offset            *int32
	ordering          *string
	q                 *string
	user              *[]string
	userN             *[]string
	userId            *[]int32
	userIdN           *[]int32
}

func (r ApiUsersPermissionsListRequest) CanAdd(canAdd bool) ApiUsersPermissionsListRequest {
	r.canAdd = &canAdd
	return r
}

func (r ApiUsersPermissionsListRequest) CanChange(canChange bool) ApiUsersPermissionsListRequest {
	r.canChange = &canChange
	return r
}

func (r ApiUsersPermissionsListRequest) CanDelete(canDelete bool) ApiUsersPermissionsListRequest {
	r.canDelete = &canDelete
	return r
}

func (r ApiUsersPermissionsListRequest) CanView(canView bool) ApiUsersPermissionsListRequest {
	r.canView = &canView
	return r
}

func (r ApiUsersPermissionsListRequest) Description(description []string) ApiUsersPermissionsListRequest {
	r.description = &description
	return r
}

func (r ApiUsersPermissionsListRequest) DescriptionEmpty(descriptionEmpty bool) ApiUsersPermissionsListRequest {
	r.descriptionEmpty = &descriptionEmpty
	return r
}

func (r ApiUsersPermissionsListRequest) DescriptionIc(descriptionIc []string) ApiUsersPermissionsListRequest {
	r.descriptionIc = &descriptionIc
	return r
}

func (r ApiUsersPermissionsListRequest) DescriptionIe(descriptionIe []string) ApiUsersPermissionsListRequest {
	r.descriptionIe = &descriptionIe
	return r
}

func (r ApiUsersPermissionsListRequest) DescriptionIew(descriptionIew []string) ApiUsersPermissionsListRequest {
	r.descriptionIew = &descriptionIew
	return r
}

func (r ApiUsersPermissionsListRequest) DescriptionIregex(descriptionIregex []string) ApiUsersPermissionsListRequest {
	r.descriptionIregex = &descriptionIregex
	return r
}

func (r ApiUsersPermissionsListRequest) DescriptionIsw(descriptionIsw []string) ApiUsersPermissionsListRequest {
	r.descriptionIsw = &descriptionIsw
	return r
}

func (r ApiUsersPermissionsListRequest) DescriptionN(descriptionN []string) ApiUsersPermissionsListRequest {
	r.descriptionN = &descriptionN
	return r
}

func (r ApiUsersPermissionsListRequest) DescriptionNic(descriptionNic []string) ApiUsersPermissionsListRequest {
	r.descriptionNic = &descriptionNic
	return r
}

func (r ApiUsersPermissionsListRequest) DescriptionNie(descriptionNie []string) ApiUsersPermissionsListRequest {
	r.descriptionNie = &descriptionNie
	return r
}

func (r ApiUsersPermissionsListRequest) DescriptionNiew(descriptionNiew []string) ApiUsersPermissionsListRequest {
	r.descriptionNiew = &descriptionNiew
	return r
}

func (r ApiUsersPermissionsListRequest) DescriptionNisw(descriptionNisw []string) ApiUsersPermissionsListRequest {
	r.descriptionNisw = &descriptionNisw
	return r
}

func (r ApiUsersPermissionsListRequest) DescriptionRegex(descriptionRegex []string) ApiUsersPermissionsListRequest {
	r.descriptionRegex = &descriptionRegex
	return r
}

func (r ApiUsersPermissionsListRequest) Enabled(enabled bool) ApiUsersPermissionsListRequest {
	r.enabled = &enabled
	return r
}

// Group (name)
func (r ApiUsersPermissionsListRequest) Group(group []string) ApiUsersPermissionsListRequest {
	r.group = &group
	return r
}

// Group (name)
func (r ApiUsersPermissionsListRequest) GroupN(groupN []string) ApiUsersPermissionsListRequest {
	r.groupN = &groupN
	return r
}

// Group
func (r ApiUsersPermissionsListRequest) GroupId(groupId []int32) ApiUsersPermissionsListRequest {
	r.groupId = &groupId
	return r
}

// Group
func (r ApiUsersPermissionsListRequest) GroupIdN(groupIdN []int32) ApiUsersPermissionsListRequest {
	r.groupIdN = &groupIdN
	return r
}

func (r ApiUsersPermissionsListRequest) Id(id []int32) ApiUsersPermissionsListRequest {
	r.id = &id
	return r
}

func (r ApiUsersPermissionsListRequest) IdEmpty(idEmpty bool) ApiUsersPermissionsListRequest {
	r.idEmpty = &idEmpty
	return r
}

func (r ApiUsersPermissionsListRequest) IdGt(idGt []int32) ApiUsersPermissionsListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiUsersPermissionsListRequest) IdGte(idGte []int32) ApiUsersPermissionsListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiUsersPermissionsListRequest) IdLt(idLt []int32) ApiUsersPermissionsListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiUsersPermissionsListRequest) IdLte(idLte []int32) ApiUsersPermissionsListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiUsersPermissionsListRequest) IdN(idN []int32) ApiUsersPermissionsListRequest {
	r.idN = &idN
	return r
}

// Number of results to return per page.
func (r ApiUsersPermissionsListRequest) Limit(limit int32) ApiUsersPermissionsListRequest {
	r.limit = &limit
	return r
}

func (r ApiUsersPermissionsListRequest) Name(name []string) ApiUsersPermissionsListRequest {
	r.name = &name
	return r
}

func (r ApiUsersPermissionsListRequest) NameEmpty(nameEmpty bool) ApiUsersPermissionsListRequest {
	r.nameEmpty = &nameEmpty
	return r
}

func (r ApiUsersPermissionsListRequest) NameIc(nameIc []string) ApiUsersPermissionsListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiUsersPermissionsListRequest) NameIe(nameIe []string) ApiUsersPermissionsListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiUsersPermissionsListRequest) NameIew(nameIew []string) ApiUsersPermissionsListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiUsersPermissionsListRequest) NameIregex(nameIregex []string) ApiUsersPermissionsListRequest {
	r.nameIregex = &nameIregex
	return r
}

func (r ApiUsersPermissionsListRequest) NameIsw(nameIsw []string) ApiUsersPermissionsListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiUsersPermissionsListRequest) NameN(nameN []string) ApiUsersPermissionsListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiUsersPermissionsListRequest) NameNic(nameNic []string) ApiUsersPermissionsListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiUsersPermissionsListRequest) NameNie(nameNie []string) ApiUsersPermissionsListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiUsersPermissionsListRequest) NameNiew(nameNiew []string) ApiUsersPermissionsListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiUsersPermissionsListRequest) NameNisw(nameNisw []string) ApiUsersPermissionsListRequest {
	r.nameNisw = &nameNisw
	return r
}

func (r ApiUsersPermissionsListRequest) NameRegex(nameRegex []string) ApiUsersPermissionsListRequest {
	r.nameRegex = &nameRegex
	return r
}

func (r ApiUsersPermissionsListRequest) ObjectType(objectType string) ApiUsersPermissionsListRequest {
	r.objectType = &objectType
	return r
}

func (r ApiUsersPermissionsListRequest) ObjectTypeIc(objectTypeIc string) ApiUsersPermissionsListRequest {
	r.objectTypeIc = &objectTypeIc
	return r
}

func (r ApiUsersPermissionsListRequest) ObjectTypeIe(objectTypeIe string) ApiUsersPermissionsListRequest {
	r.objectTypeIe = &objectTypeIe
	return r
}

func (r ApiUsersPermissionsListRequest) ObjectTypeIew(objectTypeIew string) ApiUsersPermissionsListRequest {
	r.objectTypeIew = &objectTypeIew
	return r
}

func (r ApiUsersPermissionsListRequest) ObjectTypeIregex(objectTypeIregex string) ApiUsersPermissionsListRequest {
	r.objectTypeIregex = &objectTypeIregex
	return r
}

func (r ApiUsersPermissionsListRequest) ObjectTypeIsw(objectTypeIsw string) ApiUsersPermissionsListRequest {
	r.objectTypeIsw = &objectTypeIsw
	return r
}

func (r ApiUsersPermissionsListRequest) ObjectTypeN(objectTypeN string) ApiUsersPermissionsListRequest {
	r.objectTypeN = &objectTypeN
	return r
}

func (r ApiUsersPermissionsListRequest) ObjectTypeNic(objectTypeNic string) ApiUsersPermissionsListRequest {
	r.objectTypeNic = &objectTypeNic
	return r
}

func (r ApiUsersPermissionsListRequest) ObjectTypeNie(objectTypeNie string) ApiUsersPermissionsListRequest {
	r.objectTypeNie = &objectTypeNie
	return r
}

func (r ApiUsersPermissionsListRequest) ObjectTypeNiew(objectTypeNiew string) ApiUsersPermissionsListRequest {
	r.objectTypeNiew = &objectTypeNiew
	return r
}

func (r ApiUsersPermissionsListRequest) ObjectTypeNisw(objectTypeNisw string) ApiUsersPermissionsListRequest {
	r.objectTypeNisw = &objectTypeNisw
	return r
}

func (r ApiUsersPermissionsListRequest) ObjectTypeRegex(objectTypeRegex string) ApiUsersPermissionsListRequest {
	r.objectTypeRegex = &objectTypeRegex
	return r
}

func (r ApiUsersPermissionsListRequest) ObjectTypeId(objectTypeId []int32) ApiUsersPermissionsListRequest {
	r.objectTypeId = &objectTypeId
	return r
}

func (r ApiUsersPermissionsListRequest) ObjectTypeIdN(objectTypeIdN []int32) ApiUsersPermissionsListRequest {
	r.objectTypeIdN = &objectTypeIdN
	return r
}

func (r ApiUsersPermissionsListRequest) ObjectTypes(objectTypes []int32) ApiUsersPermissionsListRequest {
	r.objectTypes = &objectTypes
	return r
}

func (r ApiUsersPermissionsListRequest) ObjectTypesN(objectTypesN []int32) ApiUsersPermissionsListRequest {
	r.objectTypesN = &objectTypesN
	return r
}

// The initial index from which to return the results.
func (r ApiUsersPermissionsListRequest) Offset(offset int32) ApiUsersPermissionsListRequest {
	r.offset = &offset
	return r
}

// Which field to use when ordering the results.
func (r ApiUsersPermissionsListRequest) Ordering(ordering string) ApiUsersPermissionsListRequest {
	r.ordering = &ordering
	return r
}

// Search
func (r ApiUsersPermissionsListRequest) Q(q string) ApiUsersPermissionsListRequest {
	r.q = &q
	return r
}

// User (name)
func (r ApiUsersPermissionsListRequest) User(user []string) ApiUsersPermissionsListRequest {
	r.user = &user
	return r
}

// User (name)
func (r ApiUsersPermissionsListRequest) UserN(userN []string) ApiUsersPermissionsListRequest {
	r.userN = &userN
	return r
}

// User
func (r ApiUsersPermissionsListRequest) UserId(userId []int32) ApiUsersPermissionsListRequest {
	r.userId = &userId
	return r
}

// User
func (r ApiUsersPermissionsListRequest) UserIdN(userIdN []int32) ApiUsersPermissionsListRequest {
	r.userIdN = &userIdN
	return r
}

func (r ApiUsersPermissionsListRequest) Execute() (*PaginatedObjectPermissionList, *http.Response, error) {
	return r.ApiService.UsersPermissionsListExecute(r)
}

/*
UsersPermissionsList Method for UsersPermissionsList

Get a list of permission objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiUsersPermissionsListRequest
*/
func (a *UsersAPIService) UsersPermissionsList(ctx context.Context) ApiUsersPermissionsListRequest {
	return ApiUsersPermissionsListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PaginatedObjectPermissionList
func (a *UsersAPIService) UsersPermissionsListExecute(r ApiUsersPermissionsListRequest) (*PaginatedObjectPermissionList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedObjectPermissionList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.UsersPermissionsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/users/permissions/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.canAdd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "can_add", r.canAdd, "form", "")
	}
	if r.canChange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "can_change", r.canChange, "form", "")
	}
	if r.canDelete != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "can_delete", r.canDelete, "form", "")
	}
	if r.canView != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "can_view", r.canView, "form", "")
	}
	if r.description != nil {
		t := *r.description
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description", t, "form", "multi")
		}
	}
	if r.descriptionEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description__empty", r.descriptionEmpty, "form", "")
	}
	if r.descriptionIc != nil {
		t := *r.descriptionIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", t, "form", "multi")
		}
	}
	if r.descriptionIe != nil {
		t := *r.descriptionIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", t, "form", "multi")
		}
	}
	if r.descriptionIew != nil {
		t := *r.descriptionIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", t, "form", "multi")
		}
	}
	if r.descriptionIregex != nil {
		t := *r.descriptionIregex
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__iregex", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__iregex", t, "form", "multi")
		}
	}
	if r.descriptionIsw != nil {
		t := *r.descriptionIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", t, "form", "multi")
		}
	}
	if r.descriptionN != nil {
		t := *r.descriptionN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", t, "form", "multi")
		}
	}
	if r.descriptionNic != nil {
		t := *r.descriptionNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", t, "form", "multi")
		}
	}
	if r.descriptionNie != nil {
		t := *r.descriptionNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", t, "form", "multi")
		}
	}
	if r.descriptionNiew != nil {
		t := *r.descriptionNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", t, "form", "multi")
		}
	}
	if r.descriptionNisw != nil {
		t := *r.descriptionNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", t, "form", "multi")
		}
	}
	if r.descriptionRegex != nil {
		t := *r.descriptionRegex
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__regex", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__regex", t, "form", "multi")
		}
	}
	if r.enabled != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enabled", r.enabled, "form", "")
	}
	if r.group != nil {
		t := *r.group
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "group", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "group", t, "form", "multi")
		}
	}
	if r.groupN != nil {
		t := *r.groupN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "group__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "group__n", t, "form", "multi")
		}
	}
	if r.groupId != nil {
		t := *r.groupId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "group_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "group_id", t, "form", "multi")
		}
	}
	if r.groupIdN != nil {
		t := *r.groupIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "group_id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "group_id__n", t, "form", "multi")
		}
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "form", "multi")
		}
	}
	if r.idEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id__empty", r.idEmpty, "form", "")
	}
	if r.idGt != nil {
		t := *r.idGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__gt", t, "form", "multi")
		}
	}
	if r.idGte != nil {
		t := *r.idGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__gte", t, "form", "multi")
		}
	}
	if r.idLt != nil {
		t := *r.idLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__lt", t, "form", "multi")
		}
	}
	if r.idLte != nil {
		t := *r.idLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__lte", t, "form", "multi")
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", t, "form", "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.name != nil {
		t := *r.name
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name", t, "form", "multi")
		}
	}
	if r.nameEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name__empty", r.nameEmpty, "form", "")
	}
	if r.nameIc != nil {
		t := *r.nameIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", t, "form", "multi")
		}
	}
	if r.nameIe != nil {
		t := *r.nameIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", t, "form", "multi")
		}
	}
	if r.nameIew != nil {
		t := *r.nameIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", t, "form", "multi")
		}
	}
	if r.nameIregex != nil {
		t := *r.nameIregex
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__iregex", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__iregex", t, "form", "multi")
		}
	}
	if r.nameIsw != nil {
		t := *r.nameIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", t, "form", "multi")
		}
	}
	if r.nameN != nil {
		t := *r.nameN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", t, "form", "multi")
		}
	}
	if r.nameNic != nil {
		t := *r.nameNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", t, "form", "multi")
		}
	}
	if r.nameNie != nil {
		t := *r.nameNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", t, "form", "multi")
		}
	}
	if r.nameNiew != nil {
		t := *r.nameNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", t, "form", "multi")
		}
	}
	if r.nameNisw != nil {
		t := *r.nameNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", t, "form", "multi")
		}
	}
	if r.nameRegex != nil {
		t := *r.nameRegex
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__regex", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__regex", t, "form", "multi")
		}
	}
	if r.objectType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "object_type", r.objectType, "form", "")
	}
	if r.objectTypeIc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "object_type__ic", r.objectTypeIc, "form", "")
	}
	if r.objectTypeIe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "object_type__ie", r.objectTypeIe, "form", "")
	}
	if r.objectTypeIew != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "object_type__iew", r.objectTypeIew, "form", "")
	}
	if r.objectTypeIregex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "object_type__iregex", r.objectTypeIregex, "form", "")
	}
	if r.objectTypeIsw != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "object_type__isw", r.objectTypeIsw, "form", "")
	}
	if r.objectTypeN != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "object_type__n", r.objectTypeN, "form", "")
	}
	if r.objectTypeNic != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "object_type__nic", r.objectTypeNic, "form", "")
	}
	if r.objectTypeNie != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "object_type__nie", r.objectTypeNie, "form", "")
	}
	if r.objectTypeNiew != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "object_type__niew", r.objectTypeNiew, "form", "")
	}
	if r.objectTypeNisw != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "object_type__nisw", r.objectTypeNisw, "form", "")
	}
	if r.objectTypeRegex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "object_type__regex", r.objectTypeRegex, "form", "")
	}
	if r.objectTypeId != nil {
		t := *r.objectTypeId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "object_type_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "object_type_id", t, "form", "multi")
		}
	}
	if r.objectTypeIdN != nil {
		t := *r.objectTypeIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "object_type_id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "object_type_id__n", t, "form", "multi")
		}
	}
	if r.objectTypes != nil {
		t := *r.objectTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "object_types", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "object_types", t, "form", "multi")
		}
	}
	if r.objectTypesN != nil {
		t := *r.objectTypesN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "object_types__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "object_types__n", t, "form", "multi")
		}
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "form", "")
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "form", "")
	}
	if r.user != nil {
		t := *r.user
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "user", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "user", t, "form", "multi")
		}
	}
	if r.userN != nil {
		t := *r.userN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "user__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "user__n", t, "form", "multi")
		}
	}
	if r.userId != nil {
		t := *r.userId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "user_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "user_id", t, "form", "multi")
		}
	}
	if r.userIdN != nil {
		t := *r.userIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "user_id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "user_id__n", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersPermissionsPartialUpdateRequest struct {
	ctx                            context.Context
	ApiService                     UsersAPI
	id                             int32
	patchedObjectPermissionRequest *PatchedObjectPermissionRequest
}

func (r ApiUsersPermissionsPartialUpdateRequest) PatchedObjectPermissionRequest(patchedObjectPermissionRequest PatchedObjectPermissionRequest) ApiUsersPermissionsPartialUpdateRequest {
	r.patchedObjectPermissionRequest = &patchedObjectPermissionRequest
	return r
}

func (r ApiUsersPermissionsPartialUpdateRequest) Execute() (*ObjectPermission, *http.Response, error) {
	return r.ApiService.UsersPermissionsPartialUpdateExecute(r)
}

/*
UsersPermissionsPartialUpdate Method for UsersPermissionsPartialUpdate

Patch a permission object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this permission.
	@return ApiUsersPermissionsPartialUpdateRequest
*/
func (a *UsersAPIService) UsersPermissionsPartialUpdate(ctx context.Context, id int32) ApiUsersPermissionsPartialUpdateRequest {
	return ApiUsersPermissionsPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return ObjectPermission
func (a *UsersAPIService) UsersPermissionsPartialUpdateExecute(r ApiUsersPermissionsPartialUpdateRequest) (*ObjectPermission, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ObjectPermission
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.UsersPermissionsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/users/permissions/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedObjectPermissionRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersPermissionsRetrieveRequest struct {
	ctx        context.Context
	ApiService UsersAPI
	id         int32
}

func (r ApiUsersPermissionsRetrieveRequest) Execute() (*ObjectPermission, *http.Response, error) {
	return r.ApiService.UsersPermissionsRetrieveExecute(r)
}

/*
UsersPermissionsRetrieve Method for UsersPermissionsRetrieve

Get a permission object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this permission.
	@return ApiUsersPermissionsRetrieveRequest
*/
func (a *UsersAPIService) UsersPermissionsRetrieve(ctx context.Context, id int32) ApiUsersPermissionsRetrieveRequest {
	return ApiUsersPermissionsRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return ObjectPermission
func (a *UsersAPIService) UsersPermissionsRetrieveExecute(r ApiUsersPermissionsRetrieveRequest) (*ObjectPermission, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ObjectPermission
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.UsersPermissionsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/users/permissions/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersPermissionsUpdateRequest struct {
	ctx                     context.Context
	ApiService              UsersAPI
	id                      int32
	objectPermissionRequest *ObjectPermissionRequest
}

func (r ApiUsersPermissionsUpdateRequest) ObjectPermissionRequest(objectPermissionRequest ObjectPermissionRequest) ApiUsersPermissionsUpdateRequest {
	r.objectPermissionRequest = &objectPermissionRequest
	return r
}

func (r ApiUsersPermissionsUpdateRequest) Execute() (*ObjectPermission, *http.Response, error) {
	return r.ApiService.UsersPermissionsUpdateExecute(r)
}

/*
UsersPermissionsUpdate Method for UsersPermissionsUpdate

Put a permission object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this permission.
	@return ApiUsersPermissionsUpdateRequest
*/
func (a *UsersAPIService) UsersPermissionsUpdate(ctx context.Context, id int32) ApiUsersPermissionsUpdateRequest {
	return ApiUsersPermissionsUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return ObjectPermission
func (a *UsersAPIService) UsersPermissionsUpdateExecute(r ApiUsersPermissionsUpdateRequest) (*ObjectPermission, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ObjectPermission
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.UsersPermissionsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/users/permissions/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.objectPermissionRequest == nil {
		return localVarReturnValue, nil, reportError("objectPermissionRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.objectPermissionRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
